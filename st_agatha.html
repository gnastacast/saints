<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js canvas - geometry - platter</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link rel="stylesheet" type="text/css" href="css/cards.css">
	</head>
	<body>

		<script src="js/three.min.js"></script>
		<script src="js/p2.min.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/renderers/Projector.js"></script>
		<script src="js/renderers/CanvasRenderer.js"></script>
		<script src="js/modifiers/SubdivisionModifier.js"></script>
		<script src="js/libs/stats.min.js"></script>
		
		<div id="canvasContainer">
				<div id="canvas">
		</div>
		</div>
		<div class="outer">
			<div class="middle">
				<div class="card">
					<div class="outerRel">
						<div class="middle">
						<p class="card"> ST. AGATHA, you suffered sexual assault and indignity because of your faith. Help heal all those who are survivors of sexual assault and protect those women who are in danger. <i>Amen</i>.</p>
						</div>
					</div>
				</div>
			</div>
		</div>
	
		<script>
		if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
		
		// scene size
		var WIDTH = window.innerWidth;
		var HEIGHT = window.innerHeight;
		
		var container, stats;
		//rendering;
		var camera, scene, renderer;
		
		var platter, bottom, titA, titB, plane, groundMirror, mirrorMesh, shadow1, shadow2;
		
		var world, circleBody1,circleBody2,nippleBody1,nippleBody2;
		
		var NIP = Math.pow(2,0);
			TIT = Math.pow(2,1);
		
		var platterSize = 20;
		var titSize = 9.5;
		var tiltSize = .4;
		var firmRatio = .85;
		var nipStiff = 25;
		var rotOffset = -1*Math.PI/2;

		var targetRotationX = 0;
		var targetRotationY = 0;
		var targetRotationOnMouseDown = Math.PI / 2;
		var accel_G = [0, 0];
		var pos_A = -titSize-titSize/10;
		var pos_B = titSize+titSize/10;
		
		var vertexPos = new THREE.Vector3();
		var zScale = 0;
		var dist = 0;
		
		heightScale = 1;
		
		var text = "";
		
		var axis = new THREE.Vector3( 0, 0, 1 );
		
		var mouseX = 0;
		var mouseXOnMouseDown = 0;

		var windowHalfX = WIDTH / 2;
		var windowHalfY = HEIGHT / 2;	
		
		THREE.DefaultLoadingManager.onLoad = function ( item, loaded, total ) {
			console.log( item, loaded, total );
		};
		
		var oldTime=Date.now();
		
		init();
		makePhysics();
		animate();
			
		function init() {

			container = document.getElementById( 'canvas' );
			container.style.position = 'absolute';
			container.style.top = "-5%";
			document.getElementById( 'canvasContainer' ).appendChild( container );
			
			renderer = new THREE.WebGLRenderer( { alpha: true, antialias: true } );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setClearColor( 0x000000,0 );
			renderer.setSize( WIDTH, HEIGHT*heightScale);
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.PCFSoftShadowMap;
			container.appendChild( renderer.domElement );

			
			
			camera = new THREE.PerspectiveCamera( 50, WIDTH / (HEIGHT*heightScale), 1, 1000 );
			camera.position.y = 30;
			camera.position.z = 100;
			//camera.rotation.x = -.6;
			camera.up = new THREE.Vector3(0,0,-1);
			camera.lookAt(new THREE.Vector3(0,0,40));

			scene = new THREE.Scene();

			spotlight = new THREE.SpotLight( 0x332522 );
			spotlight.shadowDarkness = 0.7;
			spotlight.intensity = .1;
			spotlight.position.set( 0, 40, -10 );
			spotlight.angle = Math.PI;
			spotlight.target.position.set( 0, 0, 0 );
			spotlight.shadowCameraNear	= 0.01;		
			spotlight.castShadow		= true;
			scene.add( spotlight );
			
			light2 = new THREE.DirectionalLight( 0xFFFFFF);
			light2.position.set( 0, 40, -10 ).normalize();
			scene.add( light2 );
			spotlight.intensity = 2;
			
			light3 = new THREE.DirectionalLight( 0x443311);
			light3.position.set( 0, 0, 3 ).normalize();
			scene.add( light3 );
			
			var loader = new THREE.JSONLoader();
			
			// Platter
			var path = "resources/agatha/cube/";
			var format = '.jpg';
			var urls = [
				path + 'px' + format, path + 'nx' + format,
				path + 'py' + format, path + 'ny' + format,
				path + 'pz' + format, path + 'nz' + format
			];

			var textureCube = THREE.ImageUtils.loadTextureCube( urls );
			var material = new THREE.MeshBasicMaterial( { color: 0xffffff, envMap: textureCube } );
			
			platter= new THREE.Mesh(new THREE.CircleGeometry(10),material);
			platter.castShadow = false;
			platter.receiveShadow = true;
			scene.add(platter);
			platter.rotation.x = rotOffset;
			loader.load( "resources/agatha/platter.js", createPlatter);
			
			
			var material = new THREE.MeshBasicMaterial( { color: 0xdddddd, envMap: textureCube } );
			bottom= new THREE.Mesh(new THREE.CircleGeometry(10),material);
			scene.add(bottom);
			
			loader.load( "resources/agatha/platter_bottom.js", createBottom);
		
						
			//Shadow
			var texture = THREE.ImageUtils.loadTexture( "resources/agatha/shadow_center.png" );
			material = new THREE.MeshLambertMaterial({  color: 0xffffff, transparent:true, opacity:0.2, map:texture });
			shadow1 = new THREE.Mesh(new THREE.PlaneBufferGeometry(70, 70), material);
			shadow1.position.y=-15;
			shadow1.rotation.x = rotOffset;
			scene.add(shadow1);
			
			var texture = THREE.ImageUtils.loadTexture( "resources/agatha/shadow_edge.png" );
			material = new THREE.MeshLambertMaterial({  color: 0xffffff, transparent:true, opacity:0.2, map:texture });
			shadow2 = new THREE.Mesh(new THREE.PlaneBufferGeometry(70, 70), material);
			shadow2.position.y=-14.8;
			shadow2.rotation.x = rotOffset;
			scene.add(shadow2);
			
			// Tits
			loader.load( "resources/agatha/tit.js", createTits);
			
			// nipple A

			nippleA= new THREE.Object3D();
			scene.add(nippleA);
			nippleA.parent = platter;
			nippleA.position.z = 600;
			
			// nipple B

			nippleB= new THREE.Object3D();
			scene.add(nippleB);
			nippleB.parent = platter;
			nippleB.position.z = 600;

			/*
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			container.appendChild( stats.domElement );
*/
			document.addEventListener( 'mousedown', onDocumentMouseDown, false );
			document.addEventListener( 'touchstart', onDocumentTouchStart, false );
			document.addEventListener( 'touchmove', onDocumentTouchMove, false );

			//

			window.addEventListener( 'resize', onWindowResize, false );
			
		}
		
		function makePhysics(){
			
			world = new p2.World({
				gravity:accel_G
			});
			
			// Tit A physics
			circleShape1 = new p2.Circle({radius:titSize*firmRatio});
			circleShape1.collisionGroup = TIT;
			circleShape1.collisionMask = TIT;
			circleBody1 = new p2.Body({ mass:1, position:[pos_A,0] });
			circleBody1.addShape(circleShape1);
			world.addBody(circleBody1);
			circleBody1.damping = .4;
			circleBody1.angularDamping = .1;
			circleShape1.material = new p2.Material();
			
			nippleShape1 = new p2.Circle({radius:titSize*.3});
			nippleShape1.collisionGroup = NIP;
			nippleBody1 = new p2.Body({mass:1,position:[pos_A,0]});
			nippleBody1.addShape(nippleShape1);
			nippleBody1.damping = .4;
			nippleBody1.angularDamping = .1;
			nippleBody1.material = new p2.Material();
			world.addBody(nippleBody1);
			
			
			
			// Tit B physics
			circleShape2 = new p2.Circle({radius:titSize*firmRatio});
			circleShape2.collisionGroup = TIT;
			circleShape2.collisionMask = TIT;
			circleBody2 = new p2.Body({ mass:1, position:[pos_B,0] });
			circleBody2.addShape(circleShape2);
			world.addBody(circleBody2);
			circleBody2.damping = .4;
			circleBody2.angularDamping = .1;
			circleShape2.material = new p2.Material();
			
			nippleShape2 = new p2.Circle({radius:titSize*.3});
			nippleShape2.collisionGroup = NIP;
			nippleBody2 = new p2.Body({mass:1,position:[pos_B,0]});
			nippleBody2.damping = .4;
			nippleBody2.angularDamping = .1;
			nippleBody2.material = new p2.Material();
			world.addBody(nippleBody2);
			
			
			// Add a spring
            var spring1 = new p2.LinearSpring(circleBody1, nippleBody1, {
                restLength : 0,
                stiffness : nipStiff,
                localAnchorA : [0,0],
                localAnchorB : [0,0],
            });
			world.addSpring(spring1);
			
			var spring2 = new p2.LinearSpring(circleBody2, nippleBody2, {
                restLength : 0,
                stiffness : nipStiff,
                localAnchorA : [0,0],
                localAnchorB : [0,0],
            });
			world.addSpring(spring2);

			world.addContactMaterial(new p2.ContactMaterial(circleShape1.material, circleShape2.material, {
			frictionalStiffness:1,
			friction:.35,
			restitution : 1,
			stiffness : 25 // We need infinite stiffness to get exact restitution
			}));
			
			
			// Add a "null" body
			var platterBody = new p2.Body({position:[0,0]});
			world.addBody(platterBody);
			
			var constraint1 = new p2.DistanceConstraint(platterBody,circleBody1);
			world.addConstraint(constraint1);
			constraint1.upperLimitEnabled = true;
			constraint1.lowerLimitEnabled = true;
			constraint1.upperLimit = platterSize-titSize*firmRatio;
			constraint1.lowerLimit = 0;
			constraint1.setStiffness(30);
			
			var constraint2 = new p2.DistanceConstraint(platterBody,circleBody2);
			world.addConstraint(constraint2);
			constraint2.upperLimitEnabled = true;
			constraint2.lowerLimitEnabled = true;
			constraint2.upperLimit = platterSize-titSize*firmRatio;
			constraint2.lowerLimit = 0;
			constraint2.setStiffness(30);
		}
		
		function onWindowResize() {
			WIDTH = window.innerWidth;
			HEIGHT = window.innerHeight;
			
			windowHalfX = WIDTH / 2;
			windowHalfY = HEIGHT / 2;
			
			camera.aspect = (WIDTH) / (HEIGHT*heightScale);
			camera.updateProjectionMatrix();

			renderer.setSize(WIDTH , HEIGHT*heightScale);

		}

		function createTits( geometry, materials ) {

			titA = new THREE.Mesh( geometry, new THREE.MeshFaceMaterial( materials ) );
			titA.position.y = 0;
			titA.position.x = pos_A;
			titA.rotation.z = 3;
			scene.add( titA );
			titA.parent = platter;
			titA.castShadow = true;
			
			geometry2 = geometry.clone();
			
			titB = new THREE.Mesh( geometry2, new THREE.MeshFaceMaterial( materials ) );
			titB.position.y = 0;
			titB.position.x = pos_B;
			scene.add( titB );
			titB.parent = platter;
			titB.castShadow = true;
			
			geometry3 = geometry.clone();
			
			titInvis = new THREE.Mesh( geometry3 , new THREE.MeshFaceMaterial( materials ) );
			titInvis.position.y = 3000;
			titInvis.position.x = pos_B;
			scene.add( titInvis );

		}
		
		function createPlatter( geometry, materials ) {
			platter.geometry=geometry;
			platter.geometry.computeFaceNormals();
			platter.geometry.computeVertexNormals();
			platter.geometry.verticesNeedUpdate = true;
			platter.geometry.normalsNeedUpdate = true;
			platter.rotation.x = rotOffset;
		}
		
		function createBottom( geometry, materials){
			bottom.geometry=geometry;
			bottom.parent = platter;
			bottom.receiveShadow = false;
			bottom.castShadow = false;
			bottom.position.z=-.1;
		}
		
		function animate() {
			requestAnimationFrame( animate );
			world.step(Math.min((Date.now() - oldTime)/1000,1/30)*2);
			oldTime=Date.now();
			
			if ( titA && titB && titInvis && platter) {
			// Rotate tits to match platter
			
			platter.rotation.y += ( targetRotationX - platter.rotation.y )*0.05;
			platter.rotation.y = Math.max(platter.rotation.y,-tiltSize);
			platter.rotation.y = Math.min(platter.rotation.y,tiltSize);
			platter.rotation.x += ( targetRotationY - platter.rotation.x + rotOffset)*0.05;
			platter.rotation.x = Math.max(platter.rotation.x,-tiltSize + rotOffset);
			platter.rotation.x = Math.min(platter.rotation.x,tiltSize + rotOffset);

			// Calculate acceleration due to gravity
			accel_G[0] = Math.sin(platter.rotation.y);
			accel_G[1] = Math.cos(platter.rotation.x);
			
			shadow2.material.opacity = accel_G[0]*accel_G[0];
			shadow2.material.opacity += accel_G[1]*accel_G[1];
			
			shadow1.material.opacity = Math.max(.4-shadow2.material.opacity/2,0);
			
			accel_G[0] = accel_G[0]*25;
			accel_G[1] = accel_G[1]*25;
			world.gravity = accel_G;
			

			
			if (Math.abs(accel_G[0])>.01 && Math.abs(accel_G[0])>.01){
				shadow2.rotation.z = Math.atan2(-1*accel_G[0],-1*accel_G[1]);
			}
			
			nippleA.position.x=nippleBody1.position[0];
			nippleA.position.y=-1*nippleBody1.position[1];
			nippleA.rotation.z= -1*nippleBody1.angle;
			
			nippleB.position.x=nippleBody2.position[0];
			nippleB.position.y=-1*nippleBody2.position[1];
			nippleB.rotation.z= -1*nippleBody2.angle;
			
			titA.position.x=circleBody1.position[0];
			titA.position.y=-circleBody1.position[1];
			titA.position.z=0;
			titA.rotation.z=-1*circleBody1.angle;
			
			titB.position.x=circleBody2.position[0];
			titB.position.y=-circleBody2.position[1];
			titB.position.z=0;
			titB.rotation.z=-1*circleBody2.angle+.7;

			squish(titInvis,titA,titB,titSize,platter,platterSize,nippleA);
			//squish(titInvis,titA,platter,platterSize);
			
			squish(titInvis,titB,titA,titSize,platter,platterSize,nippleB);
			//squish(titInvis,titB,platter,platterSize)
			
			titA.geometry.computeFaceNormals();
			titA.geometry.computeVertexNormals();
			titA.geometry.verticesNeedUpdate = true;
			titA.geometry.normalsNeedUpdate = true;
			
			titB.geometry.computeFaceNormals();
			titB.geometry.computeVertexNormals();
			titB.geometry.verticesNeedUpdate = true;
			titB.geometry.normalsNeedUpdate = true;
			
			getFPS();
			}
			
			render();
			//stats.update();
		}

		function squish(base,object,target,sizeTarget,field,sizeField,nipple) {
			for ( var i = 0, l = object.geometry.vertices.length; i < l; i ++ ) {
				object.geometry.vertices[ i ].y =  base.geometry.vertices[ i ].y;
				object.geometry.vertices[ i ].x =  base.geometry.vertices[ i ].x;
				if (object.geometry.vertices[ i ].z < 5){
					
					//Deformation by tit
					vertexPos = base.geometry.vertices[i].clone();
					vertexPos.applyMatrix4(object.matrix);
					vertexPos.sub(target.position);
					vertexPos.applyAxisAngle(axis, circleBody1.angle);
					dist = vertexPos.length()-sizeTarget;
					vertexPos.setLength(dist);
					zScale = -1*(5-vertexPos.z)/7;
					zScale = Math.max(zScale,-.5);
							
					if (dist<0){
						text += vertexPos.y*zScale;
						object.geometry.vertices[ i ].y =  base.geometry.vertices[ i ].y+vertexPos.y*zScale;
						object.geometry.vertices[ i ].x =  base.geometry.vertices[ i ].x+vertexPos.x*zScale;
					}
					
					//Deformation by platter
					vertexPos = base.geometry.vertices[i].clone();
					vertexPos.applyMatrix4(object.matrix);
					vertexPos.sub(field.position);
					vertexPos.applyAxisAngle(axis,-1*object.rotation.z);
					dist = sizeField-vertexPos.length();
					vertexPos.setLength(dist);
					zScale = (5-vertexPos.z)/8;

					if (dist<0){
						text += vertexPos.y*zScale;
						object.geometry.vertices[ i ].y =  object.geometry.vertices[ i ].y+vertexPos.y*zScale;
						object.geometry.vertices[ i ].x =  object.geometry.vertices[ i ].x+vertexPos.x*zScale;
					}
					
				}
				//Nipple jiggle
				if (object.geometry.vertices[ i ].z > 3){
					vertexPos = nipple.position.clone().sub(object.position);
					vertexPos.z = 0;
					vertexPos.applyAxisAngle(axis,-1*object.rotation.z);
					zScale = -1*(vertexPos.z-3)/4;	
					object.geometry.vertices[ i ].y =  object.geometry.vertices[ i ].y+vertexPos.y*zScale;
					object.geometry.vertices[ i ].x =  object.geometry.vertices[ i ].x+vertexPos.x*zScale;
				}
			}
		}
		
		function render() {
			//groundMirror.updateTextureMatrix();
			//groundMirror.matrixNeedsUpdate = false;
			//groundMirror.render();
			//groundMirror.matrixNeedsUpdate = true;
			renderer.render( scene, camera );
			getFPS();

		}

		function getFPS() {
			//document.getElementById("demo").innerHTML = "FOO";
		}
		
		function onDocumentMouseDown( event ) {

			event.preventDefault();

			document.addEventListener( 'mousemove', onDocumentMouseMove, false );
			document.addEventListener( 'mouseup', onDocumentMouseUp, false );
			document.addEventListener( 'mouseout', onDocumentMouseOut, false );

			mouseXOnMouseDown = event.clientX - windowHalfX;
			mouseYOnMouseDown = event.clientY - windowHalfY;
			targetRotationOnMouseDownX = targetRotationX;
			targetRotationOnMouseDownY = targetRotationY;

		}

		function onDocumentMouseMove( event ) {

			mouseX = event.clientX - windowHalfX;
			mouseY = event.clientY - windowHalfY;
			

			targetRotationX = targetRotationOnMouseDownX + ( mouseX - mouseXOnMouseDown ) / windowHalfX;
			targetRotationY = targetRotationOnMouseDownY + ( mouseY - mouseYOnMouseDown ) / windowHalfY;
			
			targetRotationX = Math.min(targetRotationX,tiltSize);
			targetRotationX = Math.max(targetRotationX,-1*tiltSize);
			
			targetRotationY = Math.min(targetRotationY,tiltSize);
			targetRotationY = Math.max(targetRotationY,-1*tiltSize);

		}

		function onDocumentMouseUp( event ) {

			document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
			document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
			document.removeEventListener( 'mouseout', onDocumentMouseOut, false );

		}

		function onDocumentMouseOut( event ) {

			//document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
			//document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
			//document.removeEventListener( 'mouseout', onDocumentMouseOut, false );

		}

		function onDocumentTouchStart( event ) {

			if ( event.touches.length === 1 ) {

				event.preventDefault();

				mouseXOnMouseDownY = event.touches[ 0 ].pageX - windowHalfX;
				mouseXOnMouseDownY = event.touches[ 0 ].pageY - windowHalfY;
				targetRotationOnMouseDownX = targetRotationX;
				targetRotationOnMouseDownY = targetRotationY;

			}

		}

		function onDocumentTouchMove( event ) {

			if ( event.touches.length === 1 ) {

				event.preventDefault();

				mouseX = event.touches[ 0 ].pageX - windowHalfX;
				targetRotationX = targetRotationOnMouseDownX + ( mouseX - mouseXOnMouseDownY ) * 0.05;
				targetRotationX = targetRotationOnMouseDownX + ( mouseY - mouseXOnMouseDownY ) * 0.05;

			}

		}
		

		</script>
		

	</body>
</html>
