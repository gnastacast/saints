<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js canvas - geometry - platter</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link rel="stylesheet" type="text/css" href="css/cards.css">
		<style>

			#info {
				text-align: center;
				padding: 10px;
				z-index: 10;
				width: 100%;
				position: absolute;
			}

			a {
				text-decoration: underline;
				cursor: pointer;
			}

			#stats { position: absolute; top:0; left: 0 }
			#stats #fps { background: transparent !important }
			#stats #fps #fpsText { color: #aaa !important }
			#stats #fps #fpsGraph { display: none }
		</style>
	</head>
	<body>

		<script src="js/three.min.js"></script>
		<script src="js/p2.min.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/renderers/Projector.js"></script>
		<script src="js/renderers/CanvasRenderer.js"></script>
		<script src="js/BlendCharacter.js"></script>
		<script src="js/libs/stats.min.js"></script>
		

		<div class="outer">
			<div class="middle">
				<!--<div class="card">-->
					<div class="outerRel">
						<div class="middle">
						<div id="canvasContainer">
							<div id="canvas" class="card">
							</div>
						</div>
						<!--p class="card"> ST. AGATHA, you suffered sexual assault and indignity because of your faith. Help heal all those who are survivors of sexual assault and protect those women who are in danger. <i>Amen</i>.</p>-->
						</div>
					</div>
				<!--</div>-->
			</div>
		</div>
		
		<script>
		
		// scene size
		WIDTH = window.innerHeight*.49442;
		HEIGHT = window.innerHeight*.8;
		
		var world, circle1, circle2;
		
		boneRot1 = new THREE.Vector3();
		boneRot2 = new THREE.Vector3();
		circleRot1 = new THREE.Vector3();
		circleRot2 = new THREE.Vector3();
		
		arrowY = 0;
		arrowX = 0;
		arrowZ = 10000;
		
		
		var arrowSteps = 10;
		var arrowCoolDown = arrowSteps;
		var arrowDist = 20;
		
		rotStiff = 5;
		
		var container, stats;

		var camera, scene, renderer;
		
		var ribSize = 8;
		var maxDist = 20;
		
		var mouseX = 0;
		var mouseXOnMouseDown = 0;
		
		heightScale = 1;

		var windowHalfX = WIDTH / 2;
		var windowHalfY = HEIGHT / 2;
		n=0;
		
		var oldTime=Date.now();
		var frameMS = 1;
		
		makePhysics();
		init();
		animate();
		
	
		
		function init() {
			container = document.getElementById( 'canvas' );
			//container.style.position = 'absolute';
			//container.style.left = "0%";
			//container.style.top = "-5%";
			document.getElementById( 'canvasContainer' ).appendChild( container );
			
			renderer = new THREE.WebGLRenderer( { alpha: true, antialias: true } );
			//renderer = new THREE.CanvasRenderer();
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setClearColor( 0x000000,0 );
			renderer.setSize( WIDTH, HEIGHT);
			//renderer.setSize(, container.style.height);
			renderer.shadowMapEnabled = true;
			renderer.shadowMapType = THREE.PCFSoftShadowMap;
			container.appendChild( renderer.domElement );
			
			camera = new THREE.PerspectiveCamera(35, WIDTH / (HEIGHT*heightScale), 1, 1000 );
			camera.position.y = 13;
			camera.position.z = 1.8;
			camera.position.x = .2;
			camera.up = new THREE.Vector3(0,0,-1);
			camera.lookAt(new THREE.Vector3(-.2,0,2.3));

			scene = new THREE.Scene();
			
			spotlight = new THREE.SpotLight( 0xffffff);
			spotlight.shadowDarkness = 0.7;
			spotlight.intensity = 2;
			spotlight.position.set(0,20,-5);
			spotlight.exponent=0;
			spotlight.distance = 100;
			spotlight.shadowCameraNear	= 0.01;		
			spotlight.castShadow		= true;
			//spotlight.shadowCameraVisible = true;
			scene.add( spotlight );
			
			/*
			light1 = new THREE.DirectionalLight( 0xffffff );
			light1.position.set( -5, 5, -5 );
			scene.add( light1 );

			
			light2 = new THREE.DirectionalLight( 0xffffff );
			light2.position.set( 5, 5, -5 );
			scene.add( light2 );
			*/
			Sebastian = new THREE.BlendCharacter();
			Sebastian.load( "resources/sebastian/Sebastian.js", start );
			
			var loader = new THREE.JSONLoader();
			loader.load( "resources/sebastian/Arrow.js", addArrow);

			
			document.addEventListener( 'mousedown', onDocumentMouseDown, false );
			document.addEventListener( 'touchstart', onDocumentTouchStart, false );
			document.addEventListener( 'touchmove', onDocumentTouchMove, false );

			window.addEventListener( 'resize', onWindowResize, false );
			
			stats = new Stats();
			container.appendChild( stats.domElement );
		}
		
		function makePhysics(){
			world = new p2.World({
                doProfiling : true,
                gravity : [0,0]
            });
			
			world.solver.tolerance = 0.001;
			
            var box1 = new p2.Body({
                fixedRotation:true,
				mass : 1,
				damping : .5,
                position : [0, 0],
            });
            var box2 = new p2.Body({
                fixedRotation:true,
				mass : 1,
				damping : .5,
                position : [0, 0],
            });
			var top = new p2.Body({
				fixedRotation:true,
				mass:0,
				position:[0,0],
			});
			var bottom = new p2.Body({
				fixedRotation:true,
				mass:0,
				position:[0,0],
			});
			world.addBody(box1);
            world.addBody(box2);
			world.addBody(top);
			
			// Create circle
            var radius = 1;
            var circleShape = new p2.Circle(radius);
            circle1 = new p2.Body({
                mass : 1,
				angularDamping : .7,
                position : [0, 0]
            });
            circle1.addShape(circleShape);
            world.addBody(circle1);
			
			// Create circle
			var radius = .8;
            var circleShape = new p2.Circle(radius);
            circle2 = new p2.Body({
                mass : 1,
				angularDamping : .7,
                position : [0, 0]
            });
            circle2.addShape(circleShape);
            world.addBody(circle2);
			
			// Disable collisions
            var	CIRCLE  = 1,
                OTHER = 8;
			circleShape	.collisionGroup = CIRCLE;
			circleShape .collisionMask  = OTHER;
			
			//RoationalJoint 1
			rotationalSpring = new p2.RotationalSpring(box1, circle1, {
                stiffness : rotStiff,
                damping: 20
            });
			world.addSpring(rotationalSpring);
			var revolute = new p2.RevoluteConstraint(box1, circle1, {
                localPivotA: [0, 0],
                localPivotB: [0, 0],
                collideConnected:false
            });
            world.addConstraint(revolute);
			
			//RoationalJoint2
			rotationalSpring = new p2.RotationalSpring(box2, circle2, {
                stiffness : rotStiff,
                damping: 20
            });
			world.addSpring(rotationalSpring);
			var revolute = new p2.RevoluteConstraint(box2, circle2, {
                localPivotA: [0, 0],
                localPivotB: [0, 0],
                collideConnected:false
            });
            world.addConstraint(revolute);
			
            var linearSpring = new p2.LinearSpring(box1, box2, {
                restLength : 0,
                stiffness : 20,
				damping:10,
                localAnchorA : [0,0],
                localAnchorB : [0,0],
            });
            world.addSpring(linearSpring);
			
			rotationalSpring3 = new p2.RotationalSpring(circle1, circle2, {
                stiffness : 20,
                damping: 20
            });
			world.addSpring(rotationalSpring3);
			
			var s2 = new p2.LinearSpring(box1, top, {
                restLength : 0,
                stiffness : 20,
				damping:10,
                localAnchorA : [0,0],
                localAnchorB : [0,0],
            });
            world.addSpring(s2);
			
			var s3 = new p2.LinearSpring(box2, bottom, {
                restLength : 0,
                stiffness : 20,
				damping:10,
                localAnchorA : [0,0],
                localAnchorB : [0,0],
            });
            world.addSpring(s3);

		}
		
		function onWindowResize() {
			WIDTH = window.innerHeight*.49442;
			HEIGHT = window.innerHeight*.8;
			
			windowHalfX = WIDTH / 2;
			windowHalfY = HEIGHT / 2;
			
			camera.aspect = (WIDTH) / (HEIGHT*heightScale);
			camera.updateProjectionMatrix();

			renderer.setSize(WIDTH , HEIGHT*heightScale);

		}
		
		function onDocumentMouseDown( event ) {

			event.preventDefault();
			
			mouseX = event.clientX - windowHalfX;
			mouseY = event.clientY - windowHalfY;
			if(arrowCoolDown<=0){
				var topOrBottom = Math.round(Math.random());
				//document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				//document.addEventListener( 'mouseup', onDocumentMouseUp, false );
				//document.addEventListener( 'mouseout', onDocumentMouseOut, false );

				if(topOrBottom){
					arrowY = Math.random()*3.1-1.4;
					arrowZ = -2.0*Math.random()+.4;
					arrowX = 1-arrowY/2;
					//arrowX = Math.random();
					addArrowBottom(arrow.geometry,arrow.material.materials);
					setTimeout(function() { 
						circle2.applyForce([500,0],[circle2.position[0]
									+arrowX,circle2.position[1]-arrowY/10]);
					},1000*frameMS*arrowSteps);
				}
				else{
					arrowY = Math.random()*3-1.2;
					arrowZ = -2.8*Math.random()-.7;
					arrowX = -1+arrowY/2;
					addArrowTop(arrow.geometry,arrow.material.materials);
					setTimeout(function() { 
						circle1.applyForce([500,0],[circle1.position[0]
									+arrowX,circle1.position[1]-arrowY/10]);
					},1000*frameMS*arrowSteps);
				}
			}

		}

		function onDocumentMouseMove( event ) {

			mouseX = event.clientX - windowHalfX;
			mouseY = event.clientY - windowHalfY;
			

			targetRotationX = targetRotationOnMouseDownX + ( mouseX - mouseXOnMouseDown ) / windowHalfX;
			targetRotationY = targetRotationOnMouseDownY + ( mouseY - mouseYOnMouseDown ) / windowHalfY;
			
			targetRotationX = Math.min(targetRotationX,tiltSize);
			targetRotationX = Math.max(targetRotationX,-1*tiltSize);
			
			targetRotationY = Math.min(targetRotationY,tiltSize);
			targetRotationY = Math.max(targetRotationY,-1*tiltSize);

		}

		function onDocumentMouseUp( event ) {

			document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
			document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
			document.removeEventListener( 'mouseout', onDocumentMouseOut, false );

		}

		function onDocumentMouseOut( event ) {

			//document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
			//document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
			//document.removeEventListener( 'mouseout', onDocumentMouseOut, false );

		}

		function onDocumentTouchStart( event ) {

			if ( event.touches.length === 1 ) {

				event.preventDefault();

				mouseXOnMouseDownY = event.touches[ 0 ].pageX - windowHalfX;
				mouseXOnMouseDownY = event.touches[ 0 ].pageY - windowHalfY;
				targetRotationOnMouseDownX = targetRotationX;
				targetRotationOnMouseDownY = targetRotationY;

			}

		}

		function onDocumentTouchMove( event ) {

			if ( event.touches.length === 1 ) {

				event.preventDefault();

				mouseX = event.touches[ 0 ].pageX - windowHalfX;
				targetRotationX = targetRotationOnMouseDownX + ( mouseX - mouseXOnMouseDownY ) * 0.05;
				targetRotationX = targetRotationOnMouseDownX + ( mouseY - mouseXOnMouseDownY ) * 0.05;

			}

		}
		
		function start() {
			Sebastian.castShadow = false;
			Sebastian.receiveShadow = true;
			scene.add( Sebastian );
			//console.error(Sebastian.skeleton);
			//var segmentCount = 10,
			//	radius = 3,
			//	geometry = new THREE.Geometry(),
			//	material = new THREE.LineBasicMaterial({ color: 0x0000FF });
		
			//for (var i = 0; i <= segmentCount; i++) {
			//	var theta = (i / segmentCount) * Math.PI * 2;
			//	geometry.vertices.push(
			//		new THREE.Vector3(
			//			Math.cos(theta) * radius,
			//			Math.sin(theta) * radius,
			//			0));
			//}
			
			//titA= new THREE.Line( geometry, material );
			//titB= new THREE.Line( geometry, material );
			
			//Sebastian.children[0].children[0].add(titA);
			//Sebastian.children[0].children[0].children[0].add(titB);
			
			//console.error(Sebastian);


			//Sebastian.material.side = THREE.BackSide;
			boneRot1.copy(Sebastian.skeleton.bones[1].rotation);
			boneRot2.copy(Sebastian.skeleton.bones[2].rotation);
		}
		
		function animate() {
			requestAnimationFrame( animate );
			frameMS = Math.min((Date.now() - oldTime)/1000,1/30);
			world.step(frameMS);
			oldTime=Date.now();
			
			if(arrowCoolDown>0){
				arrowCoolDown -=1;
				arrow.translateY(-arrowDist/arrowSteps);
			}
			
			
			circleRot1.set(1,1,circle1.angle);
			Sebastian.skeleton.bones[1].rotation.x=circle1.position[0]*2+boneRot1.x;
			Sebastian.skeleton.bones[1].rotation.y=circle1.position[1]*2+boneRot1.y;
			Sebastian.skeleton.bones[1].rotation.z=circle1.angle*2+boneRot1.z;
			
			Sebastian.skeleton.bones[2].rotation.x=circle2.position[0]*2+boneRot2.x;
			Sebastian.skeleton.bones[2].rotation.y=circle2.position[1]*2+boneRot2.y;
			Sebastian.skeleton.bones[2].rotation.z=circle2.angle*2+boneRot2.z;
			
			
			Sebastian.geometry.verticesNeedUpdate = true;
			Sebastian.geometry.normalsNeedUpdate = true;
				
			//titA.position.x = circle1.position[0];
			//titA.position.y = circle1.position[0];
			//titA.rotation.z = circle1.angle;
			
			//titB.position.x = circle2.position[0];
			//titB.position.y = circle2.position[0];
			stats.update();
			render();
			
		}

		function render() {		
			renderer.render( scene, camera );
		}
		
		function addArrow(geometry,materials){
			arrow = new THREE.Mesh( geometry, new THREE.MeshFaceMaterial( materials ) );
			arrow.position.x=arrowY;
			arrow.position.y=arrowX;
			arrow.position.z=arrowZ;
			scene.add(arrow);
		}
		
		function addArrowTop(geometry,materials){
			arrow = new THREE.Mesh( geometry, new THREE.MeshFaceMaterial( materials ) );
			arrow.position.x=arrowY;
			arrow.position.y=arrowX;
			arrow.position.z=arrowZ;
			arrow.rotation.z=-1*Math.PI + Math.random()+.3;
			//arrow.rotation.z=-1*Math.PI+Math.random()*.6-.3;
			arrow.castShadow= true;
			Sebastian.children[0].children[0].add(arrow);
			arrowCoolDown = arrowSteps;
			arrow.translateY(arrowDist);
		}
		
		function addArrowBottom(geometry,materials){
			arrow = new THREE.Mesh( geometry, new THREE.MeshFaceMaterial( materials ) );
			arrow.position.x=arrowX;
			arrow.position.y=arrowY;
			arrow.position.z=arrowZ;
			arrow.rotation.z=-1*Math.PI/2;
			//arrow.rotation.z=-1*Math.PI/2+Math.random()*.6+.3;
			arrow.castShadow= true;
			Sebastian.children[0].children[0].children[0].add(arrow);
			arrowCoolDown = arrowSteps;
			arrow.translateY(arrowDist);
		}

		</script>
		

	</body>
</html>
