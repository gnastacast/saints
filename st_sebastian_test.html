<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js canvas - geometry - platter</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link rel="stylesheet" type="text/css" href="css/cards.css">
		<style>

			#info {
				text-align: center;
				padding: 10px;
				z-index: 10;
				width: 100%;
				position: absolute;
			}

			a {
				text-decoration: underline;
				cursor: pointer;
			}

			#stats { position: absolute; top:0; left: 0 }
			#stats #fps { background: transparent !important }
			#stats #fps #fpsText { color: #aaa !important }
			#stats #fps #fpsGraph { display: none }
		</style>
	</head>
	<body>

		<script src="js/three.min.js"></script>
		<script src="js/Gyroscope.js"></script>
		<script src="js/p2.min.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/renderers/Projector.js"></script>
		<script src="js/renderers/CanvasRenderer.js"></script>
		<script src="js/BlendCharacter.js"></script>
		<script src="js/libs/stats.min.js"></script>
		

		<div class="outer">
			<div class="middle">
				<!--<div class="card">-->
					<div class="outerRel">
						<div class="middle">
						<div id="canvasContainer">
							<div id="canvas" class="card">
							</div>
						</div>
						<!--p class="card"> ST. AGATHA, you suffered sexual assault and indignity because of your faith. Help heal all those who are survivors of sexual assault and protect those women who are in danger. <i>Amen</i>.</p>-->
						</div>
					</div>
				<!--</div>-->
			</div>
		</div>
		<script>
		
		// scene size
		WIDTH = window.innerHeight*.49442;
		HEIGHT = window.innerHeight*.8;
		
		var world, circle1, circle2;
		
		//BONE ANIMATION VARIABLES
		
		boneRot1 = new THREE.Euler();
		boneRot2 = new THREE.Euler();
		
		rotStiff = 5;
		rotDamp = 100;
		bodyDamp = .5;
		
		//ARROW SHOOTING VARIABLES
		
		var raycaster = new THREE.Raycaster();
		var raycasterVector = new THREE.Vector3(0,0,-1);
		var originVector = new THREE.Vector3(0,0,0);
		var directionVector = new THREE.Vector3(0,0,0);
		
		arrowY = 0;
		arrowX = 0;
		arrowZ = 10000;
				
		var arrowSteps = 16;
		var arrowCoolDown = arrowSteps;
		//var arrowDist = 20;
		var arrowDist = 30;
		var arrowLive = false;
		var rayDist = 2.3;
		
		var arrowOriginX = 0;
		var arrowOriginY = 0;
		var arrowOriginZ = 0;
		
		var fov = (10/360)*(2*Math.PI);
		
		var hitZoneX = -1;
		var hitZoneY = 0;
		var hitZoneZ = 2;
		var hitZoneH = 3;
		var hitZoneR = 2;
		
		var hitArray = [];
		var hitVerts = [];
		var hitBone;
		var hitPos = new THREE.Vector3(0,0,0);
		var hitPower = 350;
		
		var translation = new THREE.Vector3(0,0,0);
		var bone2parent = new THREE.Gyroscope();
		
		var container, stats;

		var camera, scene, renderer;
		
		var mouseX = 0;
		var mouseXOnMouseDown = 0;
		
		heightScale = 1;

		var windowHalfX = WIDTH / 2;
		var windowHalfY = HEIGHT / 2;
		n=0;
		
		var oldTime=Date.now();
		var frameMS = 1;
				
		var xAxis = new THREE.Vector3(1,0,0);
		var yAxis = new THREE.Vector3(0,1,0);
		
		var rotWorldMatrix;
		
		init();
		animate();

		function init() {
			container = document.getElementById( 'canvas' );
			//container.style.position = 'absolute';
			//container.style.left = "0%";
			//container.style.top = "-5%";
			document.getElementById( 'canvasContainer' ).appendChild( container );
			
			renderer = new THREE.WebGLRenderer( { alpha: true, antialias: true } );
			//renderer = new THREE.CanvasRenderer();
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setClearColor( 0x000000,0 );
			renderer.setSize( WIDTH, HEIGHT);
			//renderer.setSize(, container.style.height);
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.PCFSoftShadowMap;
			container.appendChild( renderer.domElement );
			camera = new THREE.PerspectiveCamera(10, WIDTH / (HEIGHT*heightScale), 1, 1000 );
			camera.position.y = 47;
			//camera.position.y = 0;
			camera.position.z = 1.8;
			//camera.position.z = -30;
			camera.position.x = 0;
			camera.up = new THREE.Vector3(0,0,-1);
			camera.lookAt(new THREE.Vector3(-.4,0,2.3));

			scene = new THREE.Scene();
			
			spotlight = new THREE.SpotLight( 0xffffff);
			spotlight.shadowDarkness = 0.5;
			spotlight.intensity = 1.5;
			spotlight.position.set(22,40,-10);
			spotlight.exponent=0;
			spotlight.distance = 200;
			spotlight.shadowCameraNear	= 0.01;		
			spotlight.castShadow		= true;
			spotlight.shadowMapWidth = 2048; // default is 512
			spotlight.shadowMapHeight = 2048; // default is 512
			//spotlight.shadowCameraVisible = true;
			scene.add( spotlight );
			
			/*
			light1 = new THREE.DirectionalLight( 0xffffff );
			light1.position.set( -5, 5, -5 );
			scene.add( light1 );

			
			light2 = new THREE.DirectionalLight( 0xffffff );
			light2.position.set( 5, 5, -5 );
			scene.add( light2 );
			*/
			
			var loader = new THREE.JSONLoader();
			loader.load( "resources/sebastian/Arrow.js", addArrow);
			
			loader.load( "resources/sebastian/Sebastian_Torso.js", 
				function ( geometry, materials ){
					var material = new THREE.MeshBasicMaterial( {transparent: true, opacity:0} );
					torso = new THREE.Mesh( geometry, material );
					scene.add( torso );
				});
			
			loader.load( "resources/sebastian/Sebastian_Hips.js", 
				function ( geometry, materials ){
					var material = new THREE.MeshBasicMaterial( {transparent: true, opacity:0} );
					hips = new THREE.Mesh( geometry, material );
					scene.add( hips );
				});
			
			loader.load( "resources/sebastian/butt.js", 
				function ( geometry, material ){
					var material = new THREE.MeshFaceMaterial( material );
					butt = new THREE.Mesh( geometry, material );
					scene.add( butt );
					butt.receiveShadow = true;
				});
			
			Sebastian = new THREE.BlendCharacter();
			Sebastian.load( "resources/sebastian/Sebastian.js", start );
			/*
			document.addEventListener( 'mousedown', onDocumentMouseDown, false );
			document.addEventListener( 'touchstart', onDocumentTouchStart, false );
			document.addEventListener( 'touchmove', onDocumentTouchMove, false );

			window.addEventListener( 'resize', onWindowResize, false );
			
			stats = new Stats();
			container.appendChild( stats.domElement );
			*/
		}
		
		function start() {
			Sebastian.castShadow = false;
			Sebastian.receiveShadow = true;
			scene.add( Sebastian );
			Sebastian.geometry.dynamic = true;
			//console.error(Sebastian.skeleton);
			
			/*
			var segmentCount = 10,
			radius = 3,
			geometry = new THREE.Geometry(),
			material = new THREE.LineBasicMaterial({ color: 0x0000FF });
			geometry.vertices.push(new THREE.Vector3(0,0,0));
			for (var i = 0; i <= segmentCount; i++) {
				var theta = (i / segmentCount) * Math.PI * 2;
				geometry.vertices.push(
					new THREE.Vector3(
						Math.cos(theta) * radius,
						Math.sin(theta) * radius,
						0));
			}
			titA= new THREE.Line( geometry, material );
			material = new THREE.LineBasicMaterial({ color: 0x00FF00 });
			titB= new THREE.Line( geometry, material );
			
			//Sebastian.children[0].children[0].add(titA);
			scene.add(titA);
			titA.translateZ(2);
			//Sebastian.children[0].children[0].children[0].add(titB);
			scene.add(titB);
			*/
			/*
			geometry = new THREE.Geometry();
			geometry.vertices.push(new THREE.Vector3(0,0,0));
			geometry.vertices.push(new THREE.Vector3(0,0,0));
			var material = new THREE.LineBasicMaterial( {color: 0xFF0000} );
			forceLine = new THREE.Line( geometry, material );
			scene.add( forceLine );
			forceLine.visibile = false;
			*/
			//boneRot1.copy(Sebastian.skeleton.bones[1].rotation);
			//boneRot2.copy(Sebastian.skeleton.bones[2].rotation);
			//boneRot2.copy(Sebastian.skeleton.bones[2].getWorldRotation());
			
			//bone2parent.parent = Sebastian.skeleton.bones[1];
			//bone2parent.position.copy(Sebastian.skeleton.bones[2].position);
			
			object = new THREE.Object3D();
			//Sebastian.skeleton.bones[1].add(object);
			//object.position.copy(Sebastian.skeleton.bones[2].position);
			//bone2parent.parent = object;
			
			//Sebastian.skeleton.bones[2].parent = bone2parent;
			//Sebastian.skeleton.bones[2].position.set(0,0,0);
			//Sebastian.skeleton.bones[2].position.set(0,0,3.89165)
			//Sebastian.skeleton.bones[2].rotation.set(0,0,0);
			
			//Sebastian.material.transparent=true;
			//Sebastian.material.opacity = 0;
		}
		
		function animate() {
			requestAnimationFrame( animate );
			frameMS = Math.min((Date.now() - oldTime)/1000,1/30);
			//world.step(frameMS);
			oldTime=Date.now();
			/*
			if(typeof torso !== 'undefined' && torso.parent !== Sebastian.skeleton.bones[1]){
				THREE.SceneUtils.attach(torso, scene,Sebastian.skeleton.bones[1]);
			}
			if(typeof hips !== 'undefined' && hips.parent !== Sebastian.skeleton.bones[2]){
				THREE.SceneUtils.attach(hips, scene,Sebastian.skeleton.bones[2]);
			}
			if(typeof butt !== 'undefined' && butt.parent !== Sebastian.skeleton.bones[2]){
				THREE.SceneUtils.attach(butt, scene,Sebastian.skeleton.bones[2]);
			}
			
			if(arrowCoolDown>0){
				arrowCoolDown -=1;
				if(arrowLive){
					originVector = arrow.localToWorld(raycasterVector.clone());
					directionVector = arrow.position.clone().sub(originVector).normalize();
					raycaster.set(originVector,directionVector, 0, 1);
					raycaster.far = rayDist;
					hitArray = raycaster.intersectObjects([hips,torso]);
					if (hitArray.length>0){
						arrowLive = false;
						console.log("HIT");
						THREE.SceneUtils.attach( arrow, scene, hitArray[0].object);
						var forcePos = arrow.getWorldPosition();
						forcePos.multiplyScalar(.1);
						forceLine.position.copy(forcePos);
						forceLine.geometry.vertices[1].set(0,0,hitPower);
						forceLine.geometry.vertices[1].applyEuler(arrow.getWorldRotation())
						forceLine.geometry.verticesNeedUpdate = true;
						forceLine.visible = false;
						
						if(hitArray[0].object.uuid==torso.uuid){
							console.log("Hit Torso");
							circle1.applyForce([forceLine.geometry.vertices[1].x,forceLine.geometry.vertices[1].y],[circle1.position[0]+forcePos.x,
														circle1.position[1]+forcePos.y]);
							forceLine.position.set(forceLine.position.x,forceLine.position.y,0);
						}
						if(hitArray[0].object.uuid==hips.uuid){
							console.log("Hit Hips");
							circle2.applyForce([forceLine.geometry.vertices[1].x,forceLine.geometry.vertices[1].y],[circle2.position[0]+forcePos.x,
														circle2.position[1]+forcePos.y]);
							forceLine.position.set(forceLine.position.x,forceLine.position.y,0);
						}
						
						/*
						hitPos = arrow.position.clone();
						hitPos = Sebastian.skeleton.bones[i].worldToLocal(hitPos);
						arrow.parent = Sebastian.skeleton.bones[i];
						arrow.position.copy(hitPos);
						arrow.updateMatrixWorld();
						*/
						/*
						arrow.translateZ(arrowDist/arrowSteps/2);
					}
					else{
						arrow.translateZ(arrowDist/arrowSteps);
					}
					}
			}
			else{
				if(arrowLive){
					console.log("MISS");
					scene.remove(arrow);
					arrowLive = false;
				}
			}

			
			pushVector = new THREE.Vector3(-1*circle1.position[1],-1*circle1.position[0],0);
			Sebastian.skeleton.bones[1].matrix.makeRotationFromEuler(boneRot1);
			rotateAroundWorldAxis(Sebastian.skeleton.bones[1],xAxis,pushVector.x);
			rotateAroundWorldAxis(Sebastian.skeleton.bones[1],yAxis,pushVector.y);
			Sebastian.skeleton.bones[1].rotation.z=-1*circle1.angle*2+boneRot1.z;
			Sebastian.skeleton.bones[2].position.copy(object.getWorldPosition());
			/*
			var transformMatrix = new THREE.Matrix4;
			transformMatrix.makeRotationFromEuler(boneRot2);
			var inverseRotation = Sebastian.skeleton.bones[1].rotation.clone();
			inverseRotation.set(inverseRotation.x*-1,inverseRotation.y*-1,inverseRotation.z*-1);
			var inverseMatrix = new THREE.Matrix4;
			inverseMatrix.makeRotationFromEuler(inverseRotation);
			inverseMatrix.clone(Sebastian.skeleton.bones[1].matrix);
			transformMatrix.multiplyMatrices(transformMatrix,inverseMatrix);
			Sebastian.skeleton.bones[2].matrix.copy(transformMatrix);
			*//*
			Sebastian.skeleton.bones[2].matrix.makeRotationFromEuler(boneRot2);
			pushVector = new THREE.Vector3(-1*circle2.position[0],-1*circle2.position[1],0);
			rotateAroundWorldAxis(Sebastian.skeleton.bones[2],xAxis,pushVector.x);
			rotateAroundWorldAxis(Sebastian.skeleton.bones[2],yAxis,pushVector.y);
			Sebastian.skeleton.bones[2].rotation.z=-1*circle2.angle*2+boneRot2.z;
			
			
			Sebastian.geometry.verticesNeedUpdate = true;
			Sebastian.geometry.normalsNeedUpdate = true;
			Sebastian.geometry.verticesNeedUpdate = true;
			Sebastian.geometry.normalsNeedUpdate = true; 
			Sebastian.geometry.computeFaceNormals(); 
			Sebastian.geometry.computeVertexNormals(); 
			Sebastian.geometry.computeBoundingSphere();
			
			//titA.position.x = circle1.position[0]*2;
			//titA.position.y = circle1.position[1]*2;
			//titA.rotation.z = circle1.angle;
			
			//titB.position.x = circle2.position[0]*2;
			//titB.position.y = circle2.position[1]*2;
			//titB.rotation.z = circle2.angle;
			*/
			//stats.update();
			render();
			
		}

		function render() {		
			renderer.render( scene, camera );
		}
		
		function randomInCylinder(){
			var zPos = (Math.random()*2*hitZoneH) - hitZoneH + hitZoneZ;
			var angle = (Math.random()*2*Math.PI);
			var radius = Math.random()*hitZoneR; 
			var xPos = radius*Math.sin(angle);
			var yPos = radius*Math.cos(angle);
			return new THREE.Vector3( xPos, yPos, zPos);
		}
		
		function addArrow(geometry,materials){
			arrow = new THREE.Mesh( geometry, new THREE.MeshFaceMaterial( materials ) );
			arrow.position.x=arrowY;
			arrow.position.y=arrowX;
			arrow.position.z=arrowZ;
			scene.add(arrow);
		}
		
		function addArrowTop(geometry,materials){
			arrow = new THREE.Mesh( geometry, new THREE.MeshFaceMaterial( materials ) );
			arrow.position.x=arrowOriginX;
			arrow.position.y=arrowOriginY;
			arrow.position.z=arrowOriginZ;
			arrow.lookAt(translation);
			arrow.castShadow= true;
			//Sebastian.children[0].children[0].add(arrow);
			scene.add(arrow);
			arrowLive = true;
			arrowCoolDown = arrowSteps;
			
			/*
			geometry = new THREE.Geometry(),
			material = new THREE.LineBasicMaterial({ color: 0x0000FF });
			geometry.vertices.push(
				arrow.localToWorld(raycasterVector)
			);
			geometry.vertices.push(
				arrow.position
			);
			
			var line = new THREE.Line( geometry, material );
			scene.add( line );
			//arrow.translateX(arrowDist);
			*/
		}
		
		function addArrowBottom(geometry,materials){
			arrow = new THREE.Mesh( geometry, new THREE.MeshFaceMaterial( materials ) );
			arrow.position.x=arrowX;
			arrow.position.y=arrowY;
			arrow.position.z=arrowZ;
			arrow.rotation.z=-1*Math.PI/2;
			//arrow.rotation.z=-1*Math.PI/2+Math.random()*.6+.3;
			arrow.castShadow= true;
			Sebastian.children[0].children[0].children[0].add(arrow);
			arrowCoolDown = arrowSteps;
			arrow.translateY(arrowDist);
		}

		</script>
		

	</body>
</html>
